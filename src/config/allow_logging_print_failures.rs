//! Determines whether or not errors generated by [Stdout::write()](std::io::Stdout::write()) and [Stderr::write()](std::io::Stderr::write()) errors should be added to the message queue.
//! 
//! # Default: **true**

use std::sync::atomic::{AtomicBool, Ordering};

/// Current value of [ALLOW_LOGGING_PRINT_FAILURES](self).
static CURRENT: AtomicBool = AtomicBool::new(true);

/// Environment variable name for global config [ALLOW_LOGGING_PRINT_FAILURES](self).
pub const ENV_NAME: &str = "COMFY_PRINT_ALLOW_LOGGING_PRINT_FAILURES";

/// Get global config [ALLOW_LOGGING_PRINT_FAILURES](self).
pub fn get() -> bool { return CURRENT.load(Ordering::Relaxed); }

/// Set global config [ALLOW_LOGGING_PRINT_FAILURES](self).
pub fn set(new_value: bool) { CURRENT.store(new_value, Ordering::Relaxed); }

#[test]
fn test() {
	use crate::test_utils;

	{
		set(true);
		assert_eq!(get(), true);
	
		set(false);
		assert_eq!(get(), false);
	}

	{
		std::env::set_var(ENV_NAME, "true");
		super::env_vars::load_all();
		assert_eq!(get(), true);

		std::env::set_var(ENV_NAME, "false");
		super::env_vars::load_all();
		assert_eq!(get(), false);
	}

	{
		crate::comfy_println!("Test_01");
		assert_eq!(test_utils::get_queue().len(), 0);
	}

	{
		set(true);
		assert_eq!(get(), true);

		crate::comfy_println!("Test_02");
		assert_eq!(test_utils::get_queue().len(), 0);
	}

	{
		test_utils::write_fail_once();
		crate::comfy_print!("Test_03\n");

		let queue = test_utils::get_queue();
		assert_eq!(queue.len(), 2);
		assert_eq!(queue[0].output_kind(), crate::message::OutputKind::Stderr);
		assert_eq!(queue[1].output_kind(), crate::message::OutputKind::Stdout);
		drop(queue);
	}
	
	test_utils::yield_until_idle();
	
	{
		set(false);
		assert_eq!(get(), false);

		crate::comfy_print!("Test_04\n");
		assert_eq!(test_utils::get_queue().len(), 0);
	}

	{
		test_utils::write_fail_once();
		crate::comfy_println!("Test_05");

		let queue = test_utils::get_queue();
		assert_eq!(queue.len(), 1);
		assert_eq!(queue[0].output_kind(), crate::message::OutputKind::Stdout);
		drop(queue);
	}
}
