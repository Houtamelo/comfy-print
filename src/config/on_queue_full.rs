//! Determines what to do when trying to store new messages on a queue that reached [MAX_QUEUE_LENGTH](crate::config::max_queue_length).
//! This only applies to user-generated messages, errors generated by [Stdout::write()](std::io::Stdout::write()) and [Stderr::write()](std::io::Stderr::write()) will always follow [KeepOldest](On_QueueFull::KeepOldest), meaning they will never replace user messages.
//! 0. **KeepOldest**: Do not store the message.
//! 1. **KeepNewest**: Remove the oldest message from the queue and store the new message.
//! 
//! # Default: [KeepOldest](On_QueueFull::KeepOldest)
//! 
//! # PS
//! This config is only checked when trying to add messages to the queue.
//! `std::io::Error` messages already in the queue count as user messages. 

use std::str::FromStr;
use std::sync::atomic::{AtomicU8, Ordering};

/// Current value of [ON_QUEUE_FULL](self).
static CURRENT: AtomicU8 = AtomicU8::new(0);

/// Environment variable name for global config [ON_QUEUE_FULL](self).
pub const ENV_NAME: &str = "COMFY_PRINT_ON_QUEUE_FULL";

/// See [ON_QUEUE_FULL](self).
#[repr(u8)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum On_QueueFull {
	/// If the queue is full, do not store new messages.
	KeepOldest = 0,
	/// If the queue is full, remove the oldest message and store the new message.
	KeepNewest = 1,
}

impl FromStr for On_QueueFull {
	type Err = String;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		match s {
			"0" | "KeepOldest" => Ok(On_QueueFull::KeepOldest),
			"1" | "KeepNewest" => Ok(On_QueueFull::KeepNewest),
			_ => Err(format!("Invalid string value for On_QueueFull: {}", s)),
		}
	}
}

/// Get global config [ON_QUEUE_FULL](self).
pub fn get() -> On_QueueFull {
	return match CURRENT.load(Ordering::Relaxed) {
		1 => On_QueueFull::KeepNewest,
		_ => On_QueueFull::KeepOldest, // 0
	};
}

/// Set global config [ON_QUEUE_FULL](self).
pub fn set(new_value: On_QueueFull) {
	CURRENT.store(new_value as u8, Ordering::Relaxed);
}

#[test]
fn test() {
	use crate::test_utils;
	use crate::config;

	// Just so the error messages don't interfere with the test.
	config::allow_logging_print_failures::set(false);

	config::max_retries::set(0);
	config::on_max_retries_reached::set(config::on_max_retries_reached::On_MaxRetriesReached::Return);

	config::max_queue_length::set(4);

	{
		let current = get();
		std::env::set_var(ENV_NAME, "142354345346");
		super::env_vars::load_all();
		assert_eq!(get(), current);
	}

	{
		set(On_QueueFull::KeepOldest);
		assert_eq!(get(), On_QueueFull::KeepOldest);

		set(On_QueueFull::KeepNewest);
		assert_eq!(get(), On_QueueFull::KeepNewest);
	}

	{
		std::env::set_var(ENV_NAME, "0");
		super::env_vars::load_all();
		assert_eq!(get(), On_QueueFull::KeepOldest);

		std::env::set_var(ENV_NAME, "1");
		super::env_vars::load_all();
		assert_eq!(get(), On_QueueFull::KeepNewest);
	}

	{
		std::env::set_var(ENV_NAME, "KeepOldest");
		super::env_vars::load_all();
		assert_eq!(get(), On_QueueFull::KeepOldest);

		std::env::set_var(ENV_NAME, "KeepNewest");
		super::env_vars::load_all();
		assert_eq!(get(), On_QueueFull::KeepNewest);
	}

	{
		set(On_QueueFull::KeepOldest);
		assert_eq!(get(), On_QueueFull::KeepOldest);

		test_utils::set_toggle_write_fail(true);
		crate::comfy_println!("Test_01");
		assert_eq!(test_utils::get_queue().len(), 1);

		test_utils::yield_until_idle();
		assert_eq!(test_utils::get_queue().len(), 1);

		for index in 2..=5 {
			crate::comfy_println!("Test_0{index}");
		}

		let queue = test_utils::get_queue();
		assert_eq!(queue.len(), 4);
		assert_eq!(queue[0].str(), "Test_01");
		assert_eq!(queue[1].str(), "Test_02");
		assert_eq!(queue[2].str(), "Test_03");
		assert_eq!(queue[3].str(), "Test_04");
		drop(queue);

		test_utils::set_toggle_write_fail(false);
		crate::comfy_eprint!("Test_05\n");

		test_utils::yield_until_idle();
		assert_eq!(test_utils::get_queue().len(), 0);
	}
	
	{
		set(On_QueueFull::KeepNewest);
		assert_eq!(get(), On_QueueFull::KeepNewest);

		test_utils::set_toggle_write_fail(true);
		crate::comfy_eprint!("Test_01\n");
		assert_eq!(test_utils::get_queue().len(), 1);

		test_utils::yield_until_idle();
		assert_eq!(test_utils::get_queue().len(), 1);

		for index in 2..=5 {
			crate::comfy_println!("Test_0{index}");
		}

		let queue = test_utils::get_queue();
		assert_eq!(queue.len(), 4);
		assert_eq!(queue[0].str(), "Test_02");
		assert_eq!(queue[1].str(), "Test_03");
		assert_eq!(queue[2].str(), "Test_04");
		assert_eq!(queue[3].str(), "Test_05");
		drop(queue);

		test_utils::set_toggle_write_fail(false);
		crate::comfy_println!("Test_06");

		test_utils::yield_until_idle();
		assert_eq!(test_utils::get_queue().len(), 0);
	}
}